<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Textarium</title>
    <style>
        @font-face {
            font-family: "Atkinson";
            src: url("../src/fonts/AtkinsonHyperlegibleNextVF-Variable.woff2") format("woff2-variations");
            font-style: normal;
        }

        @font-face {
            font-family: "AtkinsonMono";
            src: url("../src/fonts/AtkinsonHyperlegibleMono-Medium.woff2") format("woff2-variations");
            font-style: normal;
        }

        @font-face {
            font-family: "AtkinsonMono";
            src: url("../src/fonts/AtkinsonHyperlegibleMono-Bold.woff2") format("woff2-variations");
            font-style: normal;
            font-weight: bold;
        }

        code, pre, kbd, samp, tt, textarea {
            font-family: "AtkinsonMono", monospace;
        } 

        :root {
            font-size: calc(0.9vw + 0.9vh);
        }

        html {
            overscroll-behavior: none;
        }

        body {
            font-family: Atkinson, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            line-height: 1.3;
            color: #333;
            overflow: hidden;
        }

        .extracted {
            padding: 0 .2rem;
            margin: 0 -.2rem;
            width: fit-content;
            text-align: center;
        }

        .annotation {
            background-color: transparent;
            border-radius: 1rem;
            padding: .1rem .4rem 0 .4rem;
            position: absolute;
            max-width: 14rem;
            overflow: hidden;
            text-overflow: ellipsis;
            text-wrap: nowrap;            
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 30;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -ms-user-select: none;
        }
        
        .annotation.abstraction-type {
            color: black;
            font-style: italic;
        }

        #app {
            display: grid;
            grid-template-columns: 50% 50%;
        }

        #text-wrapper {
            z-index: 20;
            font-size: .9rem;
            padding: 1rem 2rem;
            overflow-y: auto;            
            height: 100vh;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: auto;
            text-align: left;
            direction: rtl;
        }
        #text-wrapper > * {
            direction: ltr; 
            text-align: left;

        }

        #text-wrapper span:not(.extracted) {
            text-shadow: 0 0 .05rem white, 0 0 .1rem white, 0 0 .2rem white, 0 0 .3rem white;
        }

        #text-wrapper span:active {
            text-shadow: none;
        }

        #connections-wrapper,
        #annotations-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #connections-wrapper {
            pointer-events: none;
            z-index: -1;
        }
        
        .abstraction-texts {
            text-align: center;
            opacity: 0;
            display: none;
            transition-property: opacity;
            transition-delay: .4s;                         
            transition-duration: .4s;                   
        }

        .embedded .annotation {
            opacity: 0;
            transition-property: opacity top left;
            transition-delay: 0s;          
            transition-duration: .4s;                   
        }
        
        .annotation.no-transition {
           transition-property: opacity !important;
        }

        .annotation.maybeRemove {
            transition-duration: .2s !important;
        }

        .abstraction-texts {
            position: absolute;
            background: none;
            border: none;
            width: fit-content;
            text-wrap: wrap;
            max-width: 50vw;
            font-size: 1rem;                        
        }

        .abstraction-texts:not(.editable) {
            cursor: grab;
        }

        .abstraction-texts.editable {
            cursor: text;
        }

        .ngram {
            padding: 0 0.2rem;
            margin: 0 -0.2rem;
            z-index: -1;
        }

        .embedded .extracted,
        .embedded .annotation,
        .embedded .abstraction-texts:not(.editable) {
            cursor: unset;
            pointer-events: none;
        }

        #annotation-color-picker {opacity: .5; transition: opacity 200ms; }
        #annotation-color-picker:hover {opacity: 1; }
        #annotation-color-picker.hiding {opacity: 0; }

        @keyframes fadeIn {
            0% {
                opacity: 0;
                filter: blur(0.1rem);
            }
            100% {
                filter: blur(0);
            }
        }

        .embedded .annotation.fade-in {
            animation: fadeIn .5s .3s both;
        }

        .icon-buttons {
            position: fixed;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            z-index: 50;
            filter: grayscale(1);
        }

        .icon-buttons > div {
            width: 2.2rem;
            height: 2.2rem;
            display: none;
            align-items: center;
            justify-content: center;            
            cursor: pointer;
        }
        
        .icon-buttons > div { display: flex; } 
        /* .icon-buttons > div:first-of-type { display: none; transform: scaleX(-1); } */
        /* .embedded .icon-buttons > div:first-of-type { display: flex; transform: scaleX(-1);}  */
        .embedded .icon-buttons > div { display: none; }


        /* #edit-icon { text-decoration: none; } */

        ul { padding-left: 1rem;}
    </style>
</head>

<body class="embedded">
    <script src="../src/marked.min.js"></script>
    <div id="app">
        <div id="text-wrapper"></div>
        <div id="annotations-wrapper"></div>
        <canvas id="connections-wrapper"></canvas>
        <input type="color" id="annotation-color-picker" style="position: absolute; display: none; z-index: 1000;" />
        <div class="icon-buttons">
            <!-- <div title="Open source text and edit annotations"><a id="edit-icon" href="#" target="_parent">‚úèÔ∏è</a></div> -->
            <div title="What can I do here?" id="help-icon">‚ÑπÔ∏è</div>
            <div title="Copy Markdown link for current view" id="link-icon">üîó</div>            
        </div>
    </div>
    <script>
        // const editIcon = document.getElementById('edit-icon');
        const linkIcon = document.getElementById('link-icon');
        const helpIcon = document.getElementById('help-icon');

        const TEXTWRAPPER = document.getElementById('text-wrapper');
        const ANNOTATIONSWRAPPER = document.getElementById('annotations-wrapper');
        const CONNECTIONSWRAPPER = document.getElementById('connections-wrapper');
        const CTX = CONNECTIONSWRAPPER.getContext('2d');
        let pickerTimeout;
        let REM = parseInt(getComputedStyle(document.documentElement).fontSize);
        CONNECTIONSWRAPPER.width = window.innerWidth;
        CONNECTIONSWRAPPER.height = window.innerHeight;
        if (window.devicePixelRatio > 1) {
            var canvasWidth = CONNECTIONSWRAPPER.width;
            var canvasHeight = CONNECTIONSWRAPPER.height;

            CONNECTIONSWRAPPER.width = canvasWidth * window.devicePixelRatio;
            CONNECTIONSWRAPPER.height = canvasHeight * window.devicePixelRatio;
            CONNECTIONSWRAPPER.style.width = canvasWidth + "px";
            CONNECTIONSWRAPPER.style.height = canvasHeight + "px";

            CTX.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        CTX.globalAlpha = 1;
        const COLORS = [
            '#648fff', // Blue
            '#785ef0', // Green 
            '#dc267f', // Vermillion 
            '#fe6100', // Yellow 
            '#ffb000', // Purple 
            '#59a14f', // Green 
            '#56B4E9', // Sky Blue
            "#4e79a7",
            "#59a14f",
            "#9c755f",
            "#f28e2b",
            "#edc948",
            "#bab0ac",
            "#e15759",
            "#b07aa1",
            "#76b7b2",
            "#ff9da7",
            '#000000'
        ];

        //Animation related variables
        const MINIMUMOPACITY = 0.25; // Minimum duration in ms for animations
        let ABSTRACTIONSMINIMUMDISTANCE = REM*2; // Minimum distance in px between annotations to create an abstraction
        let ABSTRACTIONSMAXIMUMDISTANCE = REM*8; // Maximum distance in px between annotations to delete an abstraction

        // Application related variables
        const BLOBBYHULL = false;
        const hashMatch = window.location.hash.slice(1).match(/^\w+/);
        let SOURCETEXT = hashMatch ? hashMatch[0] : null;
        const WORDINDEX = [];
        const EMBEDDED = window.self !== window.top;
        const ANNOTATIONS = [];
        const ABSTRACTIONS = [];
        let colorCounter = 0;
        let gotState = false;
        let updatingHash = false;

        let dragMovement = false;
        let dragMovementObject = null
        let dragMovementOffsetX = 0;
        let dragMovementOffsetY = 0;

        function updateClosestAnnotation() {
            ANNOTATIONS.map(a => a.getDistanceToCenter())
                .sort((a, b) => a.minDistance - b.minDistance)
                .map((a, index) => {
                    if (!a) return; // Skip abstractions
                    a.annotation.isClosest = index == 0;
                });
            setURLHashState();
        }
        function sanitize(input) {
           return input.replace(/[^a-zA-Z0-9-]/g, ' ');
        }
        function slugify(text) {
            return text
                .toLowerCase()                  // convert to lowercase
                .normalize('NFD')               // decompose accents
                .replace(/[\u0300-\u036f]/g, '')// remove accents
                .replace(/[^a-z0-9_-]/g, '-')   // replace non-alphanumerics with -
                .replace(/^-+|-+$/g, '')        // trim leading/trailing dashes
                .replace(/--+/g, '-');          // collapse multiple dashes
        }
        class Annotation {
            constructor(text, abstractionType = false) {
                this.text = sanitize(text); // The word or text content of the annotation
                this.elements = this.text.match(/[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*/g) || []; // The elements of the text, split by whitespace
                this.id = slugify(this.text);
                this.referenceElement = null; // The HTML element representing the annotation
                this.positionX = 0;
                this.positionY = 0; 
                this.color = COLORS[colorCounter++ % COLORS.length]; // Color based on the text content
                this.abstraction = null;  // List of abstractions this annotation is part of
                this.stems = this.elements.map(stemmer).map(s => s.toLocaleLowerCase()); // The stemmed version of the word
                // this.related = Array.from(TEXTWRAPPER.querySelectorAll(`.${this.stems.join(' .')}`)) // All related of the word in the text
                this.related = Array.from(TEXTWRAPPER.querySelectorAll( this.stems.map(s => `.textarium_${s}`).join(' ') ))
                this.isClosest = false; // Whether this annotation is the closest to the center of the screen
                this.closestStem = null; // The closest stem to the center of the screen
                this.abstractionType = abstractionType;
                this.fadeInStart = Date.now();
                this.fadeInDuration = 500;
                this.opacity = 0;
                this.initialize();
            }
            deleteAnnotation() {
                // Ensure no race condition with double deletion
                if (ANNOTATIONS.indexOf(this) == -1) return;
                // Remove the annotation from the DOM and the global list
                this.referenceElement.remove();
                ANNOTATIONS.splice(ANNOTATIONS.indexOf(this), 1);
                // Unmark the related
                TEXTWRAPPER.querySelectorAll(`.annotation-${this.id}`).forEach((element) => {
                    let multiSelect = ANNOTATIONS.filter(a => a !== this).find(a => {
                        if (a.related.includes(element)){
                            return a
                        }
                    });
                    if(multiSelect){
                        element.classList.add(`annotation-${multiSelect.id}`);
                        element.style.backgroundColor = multiSelect.color;
                        element.style.color = getReadableTextColor(multiSelect.color);
                    }else{
                        element.classList.remove('extracted');
                        element.classList.remove(`annotation-${this.id}`);
                        element.style.backgroundColor = '';
                        element.style.color = '';
                    }

                });

                // If the annotation is part of an abstraction, remove it from the abstraction
                if (this.abstraction) {
                    this.abstraction.removeElement(this);
                    this.abstraction.checkAnnotations();
                    this.abstraction.updateTextElementPosition();
                }
                // Encode the state as a URL hash
                setURLHashState();
                delete this;
            }
            setExtractedElement(el) {
                el.classList.add('extracted');
                el.classList.add('annotation-' + this.id);
                let color = this.abstraction ? this.abstraction.averageColor : this.color;
                el.style.backgroundColor = color;
                el.style.color = getReadableTextColor(color);
                return el
            }
            initialize() {
                // Try to get existing DOM element by ID
                let referenceElement = this.referenceElement || document.getElementById(`annotation-${this.id}`);

                const needsNewElement = !referenceElement;

                if (needsNewElement) {
                    referenceElement = document.createElement('div');
                    referenceElement.id = `annotation-${this.id}`;
                    referenceElement.innerText = this.text;
                    referenceElement.classList.add('annotation');
                    referenceElement.classList.add('no-transition');

                    referenceElement.addEventListener('mousedown', (e) => setDragMovement(e, this));
                    referenceElement.addEventListener('dblclick', (e) => {
                        if (EMBEDDED) return;
                        e.preventDefault();
                        e.stopPropagation();
                        this.deleteAnnotation();
                    });

                    referenceElement.addEventListener('mouseenter', (e) => {
                        if (this.abstractionType || EMBEDDED || dragMovement) return;
                        clearTimeout(pickerTimeout);

                        const colorPicker = document.getElementById('annotation-color-picker');
                        colorPicker.classList.remove("hiding");
                        const rect = referenceElement.getBoundingClientRect();

                        const pickerRemSize = 1.5; 
                        const pickerPxSize = pickerRemSize * REM;
                        const spacingPx = 0.1 * REM;

                        colorPicker.style.left = `${rect.right}px`;
                        colorPicker.style.top = `${rect.top + window.scrollY + (rect.height - pickerPxSize) / 2}px`;

                        colorPicker.style.width = `${pickerRemSize}rem`;
                        colorPicker.style.height = `${pickerRemSize}rem`;
                        colorPicker.style.display = 'block';
                        colorPicker.value = this.color;

                        colorPicker.annotation = this;
                        colorPicker.addEventListener('mouseenter', () => clearTimeout(pickerTimeout));
                    });

                    referenceElement.addEventListener('mouseleave', () => {
                        const colorPicker = document.getElementById('annotation-color-picker');
                        pickerTimeout = setTimeout(() => {
                            if (!colorPicker.matches(':hover')) hidePicker();
                        }, 500);
                    });

                    ANNOTATIONSWRAPPER.appendChild(referenceElement);

                    if (EMBEDDED) {
                        referenceElement.classList.add('fade-in');
                        setTimeout(() => referenceElement.classList.remove('fade-in'), 600);
                    }
                }

                this.referenceElement = referenceElement;
                this.referenceElement.classList.remove("maybeRemove");
                
                if (!this.abstractionType || this.related.length > 1) {
                    this.abstractionType = false;
                    referenceElement.style.backgroundColor = this.color;
                    referenceElement.style.color = getReadableTextColor(this.color);
                }
                
                if (!EMBEDDED) this.updatePosition(window.innerWidth / 1.5, referenceElement.getBoundingClientRect().top, false);                    
                requestAnimationFrame(() => {
                    referenceElement.classList.remove('no-transition');
                });
                
                // Set ngram associations
                if (this.elements.length > 1 && this.elements.length <= 5) {
                    const n = this.elements.length;
                    const joinedStem = this.stems.join(' ');

                    let matches;
                    switch (n) {
                        case 2: matches = bigramsMap.get(joinedStem); break;
                        case 3: matches = trigramsMap.get(joinedStem); break;
                        case 4: matches = quadgramsMap.get(joinedStem); break;
                        case 5: matches = quintgramsMap.get(joinedStem); break;
                    }

                    if (matches) {
                        matches.forEach(match => {
                            match.forEach(index => {
                                const el = TEXTWRAPPER.querySelector(`#textarium_${index}`);
                                if (el) {
                                    this.setExtractedElement(el).classList.add('ngram');
                                    this.related.push(el);
                                }
                            });
                        });
                    }
                }

                this.related.forEach(el => this.setExtractedElement(el));

                if (!ANNOTATIONS.includes(this)) {
                    ANNOTATIONS.push(this);
                }

                setURLHashState();
                updateClosestAnnotation();
            }
            updatePosition(x, y, updateAbstraction = false) {
                this.positionX = x;
                this.positionY = y;
                this.referenceElement.style.left = `${this.positionX}px`;
                this.referenceElement.style.top = `${this.positionY - window.scrollY}px`;
                this.checkAnyRelatedVisible();
                if (this.abstraction != null && updateAbstraction) {
                    this.abstraction.updateTextElementPosition();
                }
                if (updateAbstraction) this.checkAbstractions();
            }

            checkAbstractions() {
                if (this.abstraction) return;

                //Check distance to all other annotations 
                ANNOTATIONS.forEach((annotation) => {
                    if (annotation !== this) {
                        let distance = Math.sqrt(
                            Math.pow(this.positionX - annotation.positionX, 2) +
                            Math.pow(this.positionY - annotation.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMINIMUMDISTANCE) {
                            // Check if there is already an abstraction with this annotation
                            if (this.abstraction != null && this.abstraction.annotations.find(a => a === annotation)) return
                            // If there is no existing abstraction, check if the annotation has an abstraction already
                            // which the current element can join 
                            if (annotation.abstraction != null) {
                                // Create a new abstraction
                                this.abstraction = annotation.abstraction;
                                this.abstraction.addElement(this);
                            } else if (this.abstraction == null && annotation.abstraction == null) {
                                // Create a new abstraction
                                let newAbstraction = new Abstraction();
                                this.abstraction = newAbstraction;
                                annotation.abstraction = newAbstraction;
                                newAbstraction.addElement(this);
                                newAbstraction.addElement(annotation);
                            }
                            setURLHashState();
                        }
                    }
                });
            }
            render() {
                let referenceElementBB = this.referenceElement.getBoundingClientRect();
                if (!referenceElementBB) return;
                let t = (Date.now() - this.fadeInStart) / this.fadeInDuration;
                this.opacity = Math.min(1, t);

                let color = this.abstraction ? this.abstraction.averageColor : this.color;
                if (this.related.length > 0) {
                    this.referenceElement.style.backgroundColor = color;
                    this.referenceElement.style.color = getReadableTextColor(color);

                    this.related.forEach(el => {
                        el.style.backgroundColor = color;
                        el.style.color = getReadableTextColor(color);
                    });
                }
                else {
                    this.referenceElement.style.backgroundColor = "transparent";                    
                }                

                this.related.forEach(el => {
                    el.style.backgroundColor = color;
                    el.style.color = getReadableTextColor(color);
                });

                let positionX = referenceElementBB.left
                let positionY = referenceElementBB.top + referenceElementBB.height / 2;
                // Render the connections to the related
                let markables = this.related;
                if (this.elements.length > 1) {
                    const n = this.elements.length;
                    markables = this.related.filter((r, i) => i % n === n - 1);
                }
                markables.forEach((stem) => {
                    let stemBB = stem.getBoundingClientRect();
                    let stemX = stemBB.left + stemBB.width;
                    let stemY = stemBB.top + stemBB.height / 2;

                    let annotationEnterX = positionX;
                    let annotationEnterY = positionY;

                    // Euclidean distance from stem to annotation
                    let dx = annotationEnterX - stemX;
                    let dy = annotationEnterY - stemY;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    let offset = Math.min(distance * 0.5, REM * 5);

                    // Control points for cubic B√©zier
                    let cp1X = stemX + offset;
                    let cp1Y = stemY;

                    let cp2X = annotationEnterX - offset;
                    let cp2Y = annotationEnterY;

                    // Draw the curve
                    CTX.beginPath();
                    CTX.moveTo(stemX, stemY);
                    CTX.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, annotationEnterX, annotationEnterY);

                    // Visibility and styling
                    const rect = stem.getBoundingClientRect();
                    const isVisible = rect.bottom > 0 && rect.top < window.innerHeight;
                    if (isVisible) CTX.strokeStyle = this.color;
                    else CTX.strokeStyle = "#0001";                    
                    CTX.lineWidth = REM / 12;
                    CTX.stroke();
                });
            }
            checkAnyRelatedVisible() {
                // Check if any of the related elements are visible in the viewport
                let visibility = this.related.some((related) => {
                    let relatedBB = related.getBoundingClientRect();
                    return (
                        relatedBB.top > 0 &&
                        relatedBB.bottom < window.innerHeight
                    );
                });
                if (visibility || this.abstractionType) {
                    this.referenceElement.style.opacity = 1;
                } else {
                    this.referenceElement.style.opacity = 0.33;
                }
                return visibility;
            }
            getDistanceToCenter() {
                if (this.abstractionType) return
                this.checkAnyRelatedVisible();
                let centerX = window.innerWidth / 2;
                let centerY = TEXTWRAPPER.scrollTop + window.innerHeight / 2;
                let minDistance = Infinity;
                let closest = null;
                this.related.forEach((stem, i) => {
                    let stemBB = stem.getBoundingClientRect();
                    let stemX = stemBB.left + stemBB.width / 2;
                    let stemY = stemBB.top + stemBB.height / 2 + TEXTWRAPPER.scrollTop;
                    let distance = Math.sqrt(
                        Math.pow(centerX - stemX, 2) +
                        Math.pow(centerY - stemY, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        this.closestStem = i;
                    }
                });
                return { closest: this.closestStem, minDistance, annotation: this }
            }
            getAsURLHash() {
                let hashString = '';
                if (this.abstractionType) {
                    hashString += '$';
                } else if (this.isClosest && this.closestStem != null) {
                    hashString += '!' + this.closestStem;
                }

                const safeElements = this.elements.map(el =>
                    el.match(/^\d/) ? '_' + el : el
                );
                const elementString = safeElements.join('_');
                if (hashString.startsWith('!') && !elementString.startsWith('_')) {
                    hashString += '_';
                }

                // Convert hex color to r,g,b ints
                const r = parseInt(this.color.slice(1, 3), 16);
                const g = parseInt(this.color.slice(3, 5), 16);
                const b = parseInt(this.color.slice(5, 7), 16);
                
                return (
                    hashString +
                    elementString +
                    `(${Math.round((this.positionX / window.innerWidth) * 1000)},${Math.round((this.positionY / window.innerHeight)*1000)},${r},${g},${b})`
                );
            }
            
        }
        class Abstraction {
            constructor(text = "A") {
                this.annotations = [];
                this.averageColor = '#888888';
                this.referenceElement = null;
                this.text = sanitize(text);
                this.id = slugify(this.text);
                this.opacity = 0;            // start transparent
                this.fadeInStart = Date.now();
                if (EMBEDDED) this.fadeInDuration = 300;
                else this.fadeInDuration = 100;
                this.initialize();
            }
            updateAverageColor() {
                const activeAnnotations = this.annotations.filter(a => a.related.length > 0);
                if (activeAnnotations.length === 0) {
                    this.averageColor = '#ffffff';
                    return;
                }

                let r = 0, g = 0, b = 0;
                activeAnnotations.forEach(a => {
                    const c = a.color;
                    r += parseInt(c.slice(1, 3), 16);
                    g += parseInt(c.slice(3, 5), 16);
                    b += parseInt(c.slice(5, 7), 16);
                });

                r = Math.round(r / activeAnnotations.length);
                g = Math.round(g / activeAnnotations.length);
                b = Math.round(b / activeAnnotations.length);

                this.averageColor = `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
            }
            initialize() {
                let abstractionTextElement = document.createElement("input");
                abstractionTextElement.type = "text";
                abstractionTextElement.classList.add("abstraction-texts");
                abstractionTextElement.style.color = this.color;
                abstractionTextElement.value = this.text;
                abstractionTextElement.style.width = (this.text.length - Math.max(0, (this.text.length * 0.15)-1)) + "ch";
                if (EMBEDDED) {
                    abstractionTextElement.readOnly = true;
                } else {
                    abstractionTextElement.addEventListener('input', (e) => {
                        const cleaned = sanitize(e.target.value);
                        this.text = cleaned;
                        e.target.value = cleaned; // enforce sanitized string in the field itself
                        abstractionTextElement.style.width = (cleaned.length - Math.max(0, (cleaned.length * 0.15) - 1)) + "ch";
                        this.updateTextElementPosition();
                        setURLHashState();
                    });
                    abstractionTextElement.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            e.target.blur();
                        }
                    });
                    abstractionTextElement.addEventListener('mousedown', (e) => setDragMovement(e, this));
                    abstractionTextElement.addEventListener("dblclick", (e) => {
                        abstractionTextElement.classList.add("editable");
                        abstractionTextElement.focus();
                        abstractionTextElement.select();
                    });
                    abstractionTextElement.addEventListener("blur", (e) => {
                        abstractionTextElement.classList.remove("editable");
                        abstractionTextElement.style.color = this.color;
                    });
                }

                this.referenceElement = abstractionTextElement;
                ANNOTATIONSWRAPPER.appendChild(abstractionTextElement);

                if (dragMovement) {
                    this.hiddenOnCreate = true;
                    abstractionTextElement.style.visibility = 'hidden';
                    abstractionTextElement.style.pointerEvents = 'none';
                    abstractionTextElement.style.opacity = 0;
                }

                ABSTRACTIONS.push(this);
            }
            addElement(annotation) {
                this.annotations.push(annotation);
                    this.updateAverageColor();

            }
            removeElement(annotation) {
                this.annotations.splice(this.annotations.indexOf(annotation), 1);
                    this.updateAverageColor();

            }
            updatePosition(x, y) {
                if (!this.referenceElement) return;
                // Move all annotations relative to the abstraction's previous position
                const prevX = parseFloat(this.referenceElement.style.left) || 0;
                const prevY = parseFloat(this.referenceElement.style.top) || 0;
                const deltaX = x - prevX;
                const deltaY = y - prevY;
                this.referenceElement.style.left = `${x}px`;
                this.referenceElement.style.top = `${y}px`;
                this.annotations.forEach((annotation) => {
                    annotation.updatePosition(annotation.positionX + deltaX, annotation.positionY + deltaY, false);
                });
                this.render();
            }
            updateTextElementPosition() {
                if (!this.referenceElement) return;
                // Position the text element at the center of all annotations
                this.text = this.referenceElement.value;
                let boundingBox = this.annotations.reduce((acc, annotation) => {
                    let element = annotation.referenceElement.getBoundingClientRect();
                    acc.left = Math.min(acc.left, element.left);
                    acc.top = Math.min(acc.top, element.top);
                    acc.right = Math.max(acc.right, element.left + element.width);
                    acc.bottom = Math.max(acc.bottom, element.top + element.height);
                    return acc;
                }, { left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity })
                let centerX = (boundingBox.left + boundingBox.right) / 2;
                let centerY = (boundingBox.top + boundingBox.bottom) / 2;                
                this.referenceElement.style.left = `${centerX - this.referenceElement.offsetWidth / 2}px`;
                this.referenceElement.style.top  = `${centerY - this.referenceElement.offsetHeight / 2}px`;
            }
            
            render() {

                if (dragMovement && !this.checkAnnotations()) return;

                let t = (Date.now() - this.fadeInStart) / this.fadeInDuration;
                this.opacity = Math.min(1, t);
                // Render the hull of the abstraction
                if (this.annotations.length < 2) {
                    this.annotations.forEach((annotation) => {
                        // Remove the annotation from the abstraction
                        annotation.abstraction = null;
                        this.removeElement(annotation);
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    return;
                }

                let padding = (parseInt(getComputedStyle(document.documentElement).fontSize)/2);

                let coordinates = this.annotations.map((annotation) => {
                    let element = annotation.referenceElement.getBoundingClientRect();
                    // return all points of the bounding rect as a two-dimensional array
                    return [
                        [element.left - padding, element.top - padding],
                        [element.left + element.width + padding, element.top - padding],
                        [element.left + element.width + padding, element.top + element.height + padding],
                        [element.left - padding, element.top + element.height + padding],
                    ];
                })
                let hull = monotoneChainConvexHull(coordinates.flat());
                if (hull.length < 3) return;
                // Draw the hull

                CTX.beginPath();

                if (BLOBBYHULL) {
                    let firstMidX, firstMidY;
                    for (let i = 0; i < hull.length; i++) {
                        const p1 = hull[i];
                        const p2 = hull[(i + 1) % hull.length];
                        const midX = (p1[0] + p2[0]) / 2;
                        const midY = (p1[1] + p2[1]) / 2;
                        if (i === 0) {
                            CTX.moveTo(midX, midY);
                            firstMidX = midX;
                            firstMidY = midY;
                        }
                        CTX.quadraticCurveTo(p1[0], p1[1], midX, midY);
                        if (i === hull.length - 1) {
                            CTX.quadraticCurveTo(p2[0], p2[1], firstMidX, firstMidY);
                        }
                    }
                } else {
                    CTX.moveTo(hull[0][0], hull[0][1]);
                    for (let i = 1; i < hull.length; i++) {
                        CTX.lineTo(hull[i][0], hull[i][1]);
                    }
                    CTX.closePath();
                }

                CTX.fillStyle = `rgba(245,245,245,${.85 * this.opacity})`;
                CTX.fill();
            }
            checkAnnotations() {
                // Check if the distance of every annotation is at least ABSTRACTIONSMAXIMUMDISTANCE to one of the others
                // if not, remove the annotation from the abstraction
                let nonVisible = []
                for (let x = 0; x < this.annotations.length; x++) {
                    let oneCloseAnnotation = false;
                    for (let y = 0; y < this.annotations.length; y++) {
                        if (x == y) continue;
                        let annotation1 = this.annotations[x];
                        let annotation2 = this.annotations[y];
                        // Check if the distance between the two annotations is below the minimum distance
                        let distance = Math.sqrt(
                            Math.pow(annotation1.positionX - annotation2.positionX, 2) +
                            Math.pow(annotation1.positionY - annotation2.positionY, 2)
                        );
                        if (distance < ABSTRACTIONSMAXIMUMDISTANCE) {
                            oneCloseAnnotation = true;
                        }
                    }
                    if (!oneCloseAnnotation) {
                        // If we reach this point, it means the annotation is too far from all others
                        this.annotations[x].abstraction = null;
                        // Remove the annotation from the abstraction
                        this.removeElement(this.annotations[x]);
                        if (this.annotations.length >= 2) {
                            this.updateTextElementPosition();
                        }
                        setURLHashState();
                    }
                    if(this.annotations[x]){
                        nonVisible.push(this.annotations[x].checkAnyRelatedVisible());
                    }
                }
                nonVisible = nonVisible.filter(n => n);
                if (nonVisible.length == 0) {
                    this.referenceElement.style.opacity = 0.2;
                }else{
                    this.referenceElement.style.opacity = 1;
                }
                if (this.annotations.length < 2) {
                    this.annotations.forEach((annotation) => {
                        // Remove the abstraction from the annotation
                        annotation.abstraction = null;
                    });
                    // Remove the abstraction from the global list
                    ABSTRACTIONS.splice(ABSTRACTIONS.indexOf(this), 1);
                    this.referenceElement.remove();
                    this.referenceElement = null;
                    setURLHashState();
                    delete this;
                    return false;
                }
                return true;
            }
            getAsURLHash() {
                // Encode the abstraction as a string for the URL hash
                return `${this.text.replaceAll(' ', '_')}(${this.annotations.map((annotation) => annotation.getAsURLHash()).join(',')})`;
            }
        }
        function getReadableTextColor(color) {
            // Function to determine the text color based on the background color based on brightness -> https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
            let r = parseInt(color.slice(1, 3), 16);
            let g = parseInt(color.slice(3, 5), 16);
            let b = parseInt(color.slice(5, 7), 16);
            // Calculate brightness
            let brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 150 ? '#000000' : '#ffffff'; // Return black or white based on brightness
        }
            
        function setDragMovement(e, dragElement) {
            if (EMBEDDED) return;
            const picker = document.getElementById('annotation-color-picker');
            picker.style.display = 'none';
            picker.annotation = null;

            e.preventDefault();
            dragMovement = true;
            dragMovementObject = dragElement;
            dragMovementObject.referenceElement.style.cursor = 'grabbing';
            let boundingClient = dragElement.referenceElement.getBoundingClientRect();
            dragMovementOffsetX = e.clientX - boundingClient.left
            if (!dragMovementObject.annotations) {
                dragMovementOffsetX -= boundingClient.width / 2;
            }
            dragMovementOffsetY = e.clientY - (boundingClient.top + boundingClient.height);
        }
        function setURLHashState() {            
            if (resetPage) return;
            if (!SOURCETEXT) return;
            updatingHash = true;
            // Set the URL hash to the current annotations
            let annotationHash = ANNOTATIONS.map((annotation) => {
                if (annotation.abstraction) return null;
                return annotation.getAsURLHash();
            }).filter((item) => item !== null)
            let abstractionHash = ABSTRACTIONS.map((abstraction) => {
                return abstraction.getAsURLHash();
            })
            let joinedHash = [...abstractionHash, ...annotationHash].join(';');
            window.location.hash = `${SOURCETEXT}&annotations=${joinedHash}`;
            updatingHash = false;
            // editIcon.href = window.location.href;
        }

        function getURLHashState() {
            resetPage = true;
            let hash = decodeURI(window.location.hash.slice(1));
            if (hash && !gotState) {
                let annotationsString = window.location.hash.match(/annotations.*/g);
                if (annotationsString) {
                    annotationsString = annotationsString[0].slice(12); // remove 'annotations='
                    annotationsArray = annotationsString.split(';');

                    annotationsArray.forEach(annotation => {
                        const isAbstraction = /\([!$a-zA-Z]/.test(annotation);

                        if (isAbstraction) {
                            // Match abstraction name and inner content
                            const match = annotation.match(/^([^\(]+)\((.*)\)$/);
                            if (!match) return;

                            const abstractionName = match[1].replaceAll('_', ' ');
                            const newAbstraction = new Abstraction(abstractionName);

                            // Extract all annotations inside abstraction
                            const inner = match[2];
                            const innerAnnotations = inner.match(/[^,]+?\([^)]*\)/g) || [];

                            innerAnnotations.forEach(entry => {
                                const ann = parseRichAnnotation(entry);
                                if (!ann) return;
                                ann.abstraction = newAbstraction;
                                newAbstraction.addElement(ann);
                            });

                            newAbstraction.updateTextElementPosition();
                            newAbstraction.referenceElement.style.opacity = 1;
                        } else {
                            const ann = parseRichAnnotation(annotation);
                            if (!ann) return;
                        }
                    });
                }
            }
            gotState = true;
            resetPage = false;
            
            if (ANNOTATIONS.length === 0 ||
                ANNOTATIONS.every(a => a.closestStem === null || a.closestStem === undefined)
            ) {                
                setTimeout(function(){TEXTWRAPPER.scrollTo({ top: 0, behavior: 'smooth' });}, 200);
            }
        }

        function parseRichAnnotation(entry) {
            const coordsMatch = entry.match(/\(([^)]+)\)/);
            const coords = coordsMatch ? coordsMatch[1].split(',').map(Number) : [];
            const [x, y, r, g, b] = coords;
            const labelPart = entry.replace(/\(.*\)$/, '');

            let ann;
            if (labelPart.startsWith('!')) {
                const closestStem = labelPart.match(/\d{1,3}/)?.[0];
                const cleanText = labelPart.replace(/!\d{1,3}/, '').replace(/^_/, '');
                ann = new Annotation(cleanText.split('_').join(' '));
                ann.isClosest = true;
                window.setTimeout(() => {
                    const el = ann.related[closestStem];
                    if (el) {
                        const wrapperTop = TEXTWRAPPER.scrollTop;
                        const elOffset = el.getBoundingClientRect().top + TEXTWRAPPER.scrollTop;
                        const elHeight = el.getBoundingClientRect().height;
                        const wrapperHeight = TEXTWRAPPER.getBoundingClientRect().height;

                        const elCenter = elOffset + elHeight / 2;
                        const targetScroll = elCenter - wrapperHeight / 2;

                        TEXTWRAPPER.scrollTo({ top: targetScroll, behavior: 'smooth' });
                    }

                }, 100);
            } else if (labelPart.startsWith('$')) {
                const cleanText = labelPart.slice(1).replace(/^_/, '');
                ann = new Annotation(cleanText.split('_').join(' '), true);
            } else {
                const cleanText = labelPart.replace(/^_/, '');
                ann = new Annotation(cleanText.split('_').join(' '));
            }

            if (!isNaN(x) && !isNaN(y)) {
                ann.updatePosition((x / 1000) * window.innerWidth, (y / 1000) * window.innerHeight, false);
            }

            if ([r, g, b].every(n => !isNaN(n))) {
                const hex = `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
                ann.color = hex;

                // set color for annotation label
                if (ann.related.length>0) {                    
                    ann.referenceElement.style.backgroundColor = hex;
                    ann.referenceElement.style.color = getReadableTextColor(hex);
                }
                
                // apply color to stems
                ann.related.forEach(el => {
                    el.style.backgroundColor = hex;
                    el.style.color = getReadableTextColor(hex);                    
                });
            }
            return ann;
        }
        
        function renderApplication() {
            // Render the application UI
            CTX.clearRect(0, 0, CONNECTIONSWRAPPER.width, CONNECTIONSWRAPPER.height);
            ANNOTATIONS.forEach((annotation) => {
                annotation.render();
            });
            ABSTRACTIONS.forEach((abstraction) => {
                abstraction.render();
            });
            requestAnimationFrame(renderApplication);
        }
        window.addEventListener('mousemove', (e) => {
            if (dragMovement && !EMBEDDED) {
                let x = e.clientX - dragMovementOffsetX;
                let y = e.clientY - dragMovementOffsetY;

                const w = window.innerWidth, h = window.innerHeight;
                const padX = w * 0.1, padY = h * 0.1;
                const stick = 200;

                let newLeft = x, newTop = y;

                // left
                if (x < w / 2 + padX) {
                    let d = w / 2 + padX - x;
                    newLeft = w / 2 + padX - d * Math.max(0, 1 - d / stick);
                }

                // right
                if (x > w - padX) {
                    let d = x - (w - padX);
                    newLeft = w - padX + d * Math.max(0, 1 - d / stick);
                }

                // top
                if (y < padY) {
                    let d = padY - y;
                    newTop = padY - d * Math.max(0, 1 - d / stick);
                }

                // bottom
                if (y > h - padY) {
                    let d = y - (h - padY);
                    newTop = h - padY + d * Math.max(0, 1 - d / stick);
                }

                if (e.shiftKey && dragMovementObject.abstraction) {
                    let dx = newLeft - dragMovementObject.positionX;
                    let dy = newTop - dragMovementObject.positionY;

                    dragMovementObject.abstraction.annotations.forEach((annotation) => {
                        annotation.updatePosition(annotation.positionX + dx, annotation.positionY + dy, false);
                    });

                    // dragMovementObject.abstraction.updateTextElementPosition();

                } else {
                    dragMovementObject.updatePosition(newLeft, newTop, true);
                }

            }
        });
        window.addEventListener('mouseup', (e) => {
            if (dragMovement && !EMBEDDED) {
                dragMovement = false;
                dragMovementObject.referenceElement.style.cursor = 'grab';
                dragMovementObject = null;

                ABSTRACTIONS.slice().forEach(abs => {
                    const el = abs.referenceElement;
                    if (!el) return;

                    if (abs.hiddenOnCreate === true) {
                        if (abs.annotations.length >= 2) {
                            el.style.visibility = 'visible';
                            el.style.pointerEvents = 'auto';
                            el.style.opacity = 1;
                            abs.hiddenOnCreate = false;
                            abs.updateTextElementPosition();
                        } else {
                            abs.annotations.forEach(a => a.abstraction = null);
                            el.remove();
                            const idx = ABSTRACTIONS.indexOf(abs);
                            if (idx > -1) ABSTRACTIONS.splice(idx, 1);
                        }
                    }
                });

                setURLHashState();
            } else if (!EMBEDDED) {
                let selection = window.getSelection();
                if (selection.toString().trim() !== '' ) {
                    const range = selection.getRangeAt(0);
                    const SOURCETEXT = selection.toString();
                    const findStartOfFirstWord = (range) => {
                        let start = range.startOffset;
                        const startContainerText = range.startContainer.textContent;
                        while (start > 0 && !/\s/.test(startContainerText[start - 1])) {
                            start--;
                        }
                        return start;
                    };
                    // Function to find the end of the last whole word
                    const findEndOfLastWord = (range) => {
                        let end = range.endOffset;
                        const endContainerText = range.endContainer.textContent;
                        while (end < endContainerText.length && !/\s/.test(endContainerText[end])) {
                            end++;
                        }
                        return end;
                    };
                    // Adjust the range to include whole words
                    range.setStart(range.startContainer, findStartOfFirstWord(range));
                    range.setEnd(range.endContainer, findEndOfLastWord(range));

                    // Clear the current selection and apply the new range
                    selection.removeAllRanges();
                    selection.addRange(range);
                    if (selection.toString().split(/[.,\s!?]/).length > 5) return;
                    // Check if an annotation with the same text already exists
                    let duplicate = ANNOTATIONS.find(a => a.text === selection.toString().trim());
                    if (duplicate) return;
                    let selectionRect = selection.anchorNode.parentElement.getBoundingClientRect();
                    // Get all word spans in this selection
                    let annotation = new Annotation(selection.toString().match(/((\w+-?)+)/g).join(' '));
                    let annotationRect = annotation.referenceElement.getBoundingClientRect();
                    let positioned = false;
                    let tries = 0;
                    while (!positioned && tries < 5) {
                        let x = annotation.positionX + tries * 50;
                        let y = selectionRect.top + annotationRect.height / 2;
                        let collision = ANNOTATIONS.find(annotationRef => {
                            if (annotationRef.id == annotation.id) return false; // don't check against itself
                            let annotationRefRect = annotationRef.referenceElement.getBoundingClientRect();
                            if (Math.abs((annotationRefRect.top + annotationRefRect.height / 2) - y) > 20) return false; // if the bboxes are not on the same y level, ignore
                            return !(Math.abs((x + annotationRect.width / 2) - (annotationRefRect.left + annotationRefRect.width / 2)) > (annotationRefRect.width));
                        })
                        if (!collision) {
                            annotation.updatePosition(x, y);
                            positioned = true;
                            tries = 0;
                            break;
                        }
                        tries++;
                        if (tries == 5 && !positioned) {
                            annotation.updatePosition(annotation.positionX, y);
                            positioned = true;
                            tries = 0;
                            break;
                        }
                    }
                    selection.removeAllRanges(); // Clear the selection after creating the annotation
                }
            }
        });
        window.addEventListener('resize', (e) => {
            REM = parseInt(getComputedStyle(document.documentElement).fontSize);
            ABSTRACTIONSMINIMUMDISTANCE = REM*2; // Minimum distance in px between annotations to create an abstraction
            ABSTRACTIONSMAXIMUMDISTANCE = REM*8; // Maximum distance in px between annotations to delete an abstraction

            CONNECTIONSWRAPPER.width = window.innerWidth;
            CONNECTIONSWRAPPER.height = window.innerHeight;
            if (window.devicePixelRatio > 1) {
                var canvasWidth = CONNECTIONSWRAPPER.width;
                var canvasHeight = CONNECTIONSWRAPPER.height;

                CONNECTIONSWRAPPER.width = canvasWidth * window.devicePixelRatio;
                CONNECTIONSWRAPPER.height = canvasHeight * window.devicePixelRatio;
                CONNECTIONSWRAPPER.style.width = canvasWidth + "px";
                CONNECTIONSWRAPPER.style.height = canvasHeight + "px";

                CTX.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            resetState();
        });
        function resetState() {
            hidePicker();
            gotState = false;
            // Remove all annotations and abstractions from the DOM
            ANNOTATIONS.splice(0, ANNOTATIONS.length)
            ABSTRACTIONS.splice(0, ABSTRACTIONS.length)
            if (EMBEDDED) document.querySelectorAll('.annotation').forEach((el) => el.classList.add("maybeRemove"));
            else document.querySelectorAll('.annotation').forEach((el) => el.remove());
            document.querySelectorAll('.abstraction-texts').forEach((el) => el.remove());
            // Unmark all related
            TEXTWRAPPER.querySelectorAll('.extracted').forEach((element) => {
                element.classList.remove('extracted');
                element.classList.forEach((cls) => {
                    if (cls.startsWith('annotation-')) {
                        element.classList.remove(cls);
                    }
                });
                element.style.backgroundColor = '';
                element.style.color = '';
            });
            colorCounter = 0;
            dragMovement = false;
            getURLHashState();
            if (EMBEDDED) {
                document.querySelectorAll('.maybeRemove').forEach((el) => el.style.opacity=0);
                setTimeout(function(){ document.querySelectorAll('.maybeRemove').forEach((el) => el.remove()); }, 300);
            }            
        }
        window.addEventListener('hashchange', (e) => {
            const newHashMatch = window.location.hash.slice(1).match(/^\w+/);
            const newSourceText = newHashMatch ? newHashMatch[0] : null;
            if (newSourceText && newSourceText !== SOURCETEXT) {
                location.reload();
                return;
            }

            if (!EMBEDDED) return;
            // editIcon.href = window.location.href;
            if (updatingHash) return;
            resetState();
        });
        window.addEventListener('popstate', (e) => {
            if (EMBEDDED) return;
            if (updatingHash) return;
            resetState();
        });
        window.addEventListener('keydown', (e) => {            
            if (EMBEDDED) return;

            if (e.key === 'Escape') {
                if (document.getElementById('annotation-color-picker').style.display === 'block') {
                    hidePicker();                    
                } else {
                    window.location.hash = `#${SOURCETEXT}`;                
                    TEXTWRAPPER.scrollTo({ top: 0, behavior: 'smooth' });                    
                }
            }            

            const isCopyShortcut = (e.metaKey && e.key === 'c') || (e.ctrlKey && e.key === 'c');
            const selection = window.getSelection();
            const isTextSelected = selection && selection.toString().trim().length > 0;

            if (isCopyShortcut && !isTextSelected && !document.activeElement.matches('input, textarea')) {
                e.preventDefault();

                const hash = window.location.hash; // e.g., #bush&annotations=...
                const markdownLink = `[](txt/${hash})`;

                navigator.clipboard.writeText(markdownLink).then(() => {
                    // console.log("Copied:", markdownLink);
                }).catch(err => {
                    console.error("Copy failed:", err);
                });
            }
        });
        TEXTWRAPPER.addEventListener('scroll', (e) => {
            ANNOTATIONS.forEach(a => a.checkAnyRelatedVisible());
            if (EMBEDDED) return;
            updateClosestAnnotation();
        })
        ANNOTATIONSWRAPPER.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (EMBEDDED) return;
            let text = window.prompt("Please enter the text for a new annotation:");
            if (text) {
                let annotation = new Annotation(text, true);
                annotation.color="#ffffff";
                annotation.updatePosition(e.clientX, e.clientY, true);
                setURLHashState();
            }
        });
        document.getElementById('annotation-color-picker').addEventListener('input', function () {
            const ann = this.annotation;
            if (!ann) return;

            const newColor = this.value;

            // Update the color of the annotation being changed
            ann.color = newColor;

            // If part of abstraction, propagate the color to other annotations
            if (ann.abstraction) {
                ann.abstraction.annotations.forEach(other => {
                    // Only update annotations that have visible stems (not abstraction-only labels)
                    if (other.related.length > 0) {
                        other.color = newColor;

                        // Immediately apply new styles
                        other.referenceElement.style.backgroundColor = newColor;
                        other.referenceElement.style.color = getReadableTextColor(newColor);

                        other.related.forEach(el => {
                            el.style.backgroundColor = newColor;
                            el.style.color = getReadableTextColor(newColor);
                        });
                    }
                });

                // Recalculate average color after changes
                ann.abstraction.updateAverageColor();
            } else {
                // Just update the annotation directly
                ann.referenceElement.style.backgroundColor = newColor;
                ann.referenceElement.style.color = getReadableTextColor(newColor);
                ann.related.forEach(el => {
                    el.style.backgroundColor = newColor;
                    el.style.color = getReadableTextColor(newColor);
                });
            }

            setURLHashState(); // Persist in URL hash
        });
        document.addEventListener('click', (event) => {
            const picker = document.getElementById('annotation-color-picker');
            const target = event.target;

            // Only hide if the click is outside both the picker and its linked annotation
            if (
                picker.style.display === 'block' &&
                target !== picker &&
                target !== picker.annotation?.referenceElement &&
                !picker.contains(target)
            ) hidePicker();
        });
        function hidePicker() {
            const picker = document.getElementById('annotation-color-picker');
            if (picker.matches(':hover')) return; // Prevent flicker
            picker.classList.add("hiding");
            pickerTimeout = setTimeout(() => {
                picker.style.display = 'none';
                picker.annotation = null;
            }, 200);
        }
        // Function to search for n-grams
        function searchNGrams(wordIndex, n) {
            const ngramMap = new Map();
            for (let i = 0; i < wordIndex.length - n + 1; i++) {
                const ngram = wordIndex.slice(i, i + n).map(word => word.stemmed).join(' ');
                if (!ngramMap.has(ngram)) {
                    ngramMap.set(ngram, []);
                }
                ngramMap.get(ngram).push(wordIndex.slice(i, i + n).map(word => `${word.word}${word.index}`));
            }
            return ngramMap;
        }
        let bigramsMap = null;
        let trigramsMap = null;
        let quadgramsMap = null;
        let quintgramsMap = null;

        if (SOURCETEXT) fetch(`${SOURCETEXT}.md`)
            .then(response => response.text())
            .then(text => {
                if (!text) {
                    console.error('No text found for the given hash:', SOURCETEXT);
                    return;
                }
                let parsedText = text
                    .replaceAll(/(?:\r\n|[\n\r\u2028\u2029])/g, '\n ')
                    .split(' ')
                    .map((word, index) => {
                        if (word != '#' && !RegExp(/[<>|]/).test(word)) {
                            let sanitizedWord = word.replace(/[^a-zA-Z0-9-]/g, '');
                            let stemmedWord = stemmer(sanitizedWord).toLocaleLowerCase();
                            if (sanitizedWord.length == 0) return word; // Skip empty words
                            WORDINDEX.push({
                                word: sanitizedWord,
                                stemmed: stemmedWord,
                                index: index
                            });
                            if (sanitizedWord.length == 1) {
                                return `<span id="textarium_${sanitizedWord + index}" class='word textarium_${stemmedWord}'>${word}</span>`; // Skip single character words
                            } else {
                                return word.replace(
                                    /([\w-]+)/g,
                                    `<span id="textarium_${sanitizedWord + index}" class='word textarium_${stemmedWord}'>$1</span>`
                                );
                            }
                        }
                        return word;
                    })
                    .join(' ');
                TEXTWRAPPER.innerHTML = marked.parse(parsedText);
                
                if (!EMBEDDED) document.querySelector('body').classList.remove('embedded');
                
            }).then(() => {
                bigramsMap = searchNGrams(WORDINDEX, 2);
                trigramsMap = searchNGrams(WORDINDEX, 3);
                quadgramsMap = searchNGrams(WORDINDEX, 4);
                quintgramsMap = searchNGrams(WORDINDEX, 5);
                getURLHashState();
                renderApplication();
            })                
        
        linkIcon.addEventListener('click', () => {
            const markdownLink = `[](txt/${window.location.hash})`;
            navigator.clipboard.writeText(markdownLink)
            .then(() => {
                linkIcon.innerText = '‚úÖ';
                setTimeout(() => linkIcon.innerText = 'üîó', 1000);
            })
            .catch(err => console.error("Copy failed:", err));
        });

        helpIcon.addEventListener('click', () => {
            alert("Usage hints:\n- Select words in the source text to create annotations.\n- Drag annotations to reposition and group them.\n- Hold Shift and drag any item to move its group.\n- Changing color of one annotation updates whole group.\n- Double-click on background to add new annotation.\n- Double-click an annotation to remove it.\n- The browser history works: go back to undo.");
        });
        
        // editIcon.href = window.location.href;

        //  Source: https://www.npmjs.com/package/monotone-chain-convex-hull?activeTab=readme
        function monotoneChainConvexHull(e, n = {}) {
            const { sorted: o } = n;
            o || (e = e.slice().sort(byXThenY));
            const t = e.length,
                r = new Array(2 * t);
            let c = 0;
            for (let n = 0; n < t; n++) {
                const o = e[n];
                for (; c >= 2 && cw(r[c - 2], r[c - 1], o) <= 0; ) c--;
                r[c++] = o;
            }
            const s = c + 1;
            for (let n = t - 2; n >= 0; n--) {
                const o = e[n];
                for (; c >= s && cw(r[c - 2], r[c - 1], o) <= 0; ) c--;
                r[c++] = o;
            }
            return r.slice(0, c - 1);
        }
        function cw(e, n, o) {
            return (n[1] - e[1]) * (o[0] - e[0]) - (n[0] - e[0]) * (o[1] - e[1]);
        }
        function byXThenY(e, n) {
            return e[0] === n[0] ? e[1] - n[1] : e[0] - n[0];
        }        

        // Source: https://www.npmjs.com/package/porter-stemmer
        var e = {
                ational: "ate",
                tional: "tion",
                enci: "ence",
                anci: "ance",
                izer: "ize",
                bli: "ble",
                alli: "al",
                entli: "ent",
                eli: "e",
                ousli: "ous",
                ization: "ize",
                ation: "ate",
                ator: "ate",
                alism: "al",
                iveness: "ive",
                fulness: "ful",
                ousness: "ous",
                aliti: "al",
                iviti: "ive",
                biliti: "ble",
                logi: "log",
            },
            t = { icate: "ic", ative: "", alize: "al", iciti: "ic", ical: "ic", ful: "", ness: "" },
            i = "[aeiouy]",
            s = "[^aeiou][^aeiouy]*",
            n = i + "[aeiou]*",
            a = "^(" + s + ")?" + n + s,
            l = "^(" + s + ")?" + n + s + "(" + n + ")?$",
            o = "^(" + s + ")?" + n + s + n + s,
            c = "^(" + s + ")?" + i;
        function stemmer(n) {
            var r, u, x, p, $, g, w;
            if (n.length < 3) return n;
            if (
                ("y" == (x = n.substr(0, 1)) && (n = x.toUpperCase() + n.substr(1)),
                ($ = /^(.+?)([^s])s$/),
                (p = /^(.+?)(ss|i)es$/).test(n) ? (n = n.replace(p, "$1$2")) : $.test(n) && (n = n.replace($, "$1$2")),
                ($ = /^(.+?)(ed|ing)$/),
                (p = /^(.+?)eed$/).test(n))
            ) {
                var f = p.exec(n);
                (p = new RegExp(a)).test(f[1]) && ((p = /.$/), (n = n.replace(p, "")));
            } else if ($.test(n)) {
                (r = (f = $.exec(n))[1]),
                    ($ = new RegExp(c)).test(r) &&
                        ((n = r),
                        ($ = /(at|bl|iz)$/),
                        (g = new RegExp("([^aeiouylsz])\\1$")),
                        (w = new RegExp("^" + s + i + "[^aeiouwxy]$")),
                        $.test(n) ? (n += "e") : g.test(n) ? ((p = /.$/), (n = n.replace(p, ""))) : w.test(n) && (n += "e"));
            }
            (p = /^(.+?)y$/).test(n) && ((r = (f = p.exec(n))[1]), (p = new RegExp(c)).test(r) && (n = r + "i"));
            (p =
                /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/).test(
                n
            ) && ((r = (f = p.exec(n))[1]), (u = f[2]), (p = new RegExp(a)).test(r) && (n = r + e[u]));
            (p = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/).test(n) &&
                ((r = (f = p.exec(n))[1]), (u = f[2]), (p = new RegExp(a)).test(r) && (n = r + t[u]));
            if ((($ = /^(.+?)(s|t)(ion)$/), (p = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/).test(n)))
                (r = (f = p.exec(n))[1]), (p = new RegExp(o)).test(r) && (n = r);
            else if ($.test(n)) {
                (r = (f = $.exec(n))[1] + f[2]), ($ = new RegExp(o)).test(r) && (n = r);
            }
            (p = /^(.+?)e$/).test(n) &&
                ((r = (f = p.exec(n))[1]),
                (p = new RegExp(o)),
                ($ = new RegExp(l)),
                (g = new RegExp("^" + s + i + "[^aeiouwxy]$")),
                (p.test(r) || ($.test(r) && !g.test(r))) && (n = r));
            return (
                (p = /ll$/),
                ($ = new RegExp(o)),
                p.test(n) && $.test(n) && ((p = /.$/), (n = n.replace(p, ""))),
                "y" == x && (n = x.toLowerCase() + n.substr(1)),
                n
            );
        }

    </script>
</body>

</html>